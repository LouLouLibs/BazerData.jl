var documenterSearchIndex = {"docs":
[{"location":"lib/internals/#Package-Internals","page":"Package Internals","title":"Package Internals","text":"","category":"section"},{"location":"lib/internals/#BazerData-Module","page":"Package Internals","title":"BazerData Module","text":"","category":"section"},{"location":"demo/stata_utils/#Stata-like-utilities","page":"Stata-like utilities","title":"Stata-like utilities","text":"","category":"section"},{"location":"demo/stata_utils/","page":"Stata-like utilities","title":"Stata-like utilities","text":"So far I have tried to implement","category":"page"},{"location":"demo/stata_utils/","page":"Stata-like utilities","title":"Stata-like utilities","text":"tabulate\nxtile\nwinsorize","category":"page"},{"location":"demo/stata_utils/","page":"Stata-like utilities","title":"Stata-like utilities","text":"Other stata-like panel stuff are panel_fill","category":"page"},{"location":"demo/stata_utils/","page":"Stata-like utilities","title":"Stata-like utilities","text":"Other packages that do similar things","category":"page"},{"location":"demo/stata_utils/","page":"Stata-like utilities","title":"Stata-like utilities","text":"See statar for a good package that implements stata feature into R.\nSee Binscatters.jl\nDouglass to work with DataFrames in Julia using a stata-like syntax.","category":"page"},{"location":"demo/stata_utils/","page":"Stata-like utilities","title":"Stata-like utilities","text":"","category":"page"},{"location":"man/winsorize_guide/#Winsorizing","page":"Winsorizing","title":"Winsorizing","text":"","category":"section"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"The function winsorize tries to emulate stata winsor function.","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"There is a winsor function in StatsBase.jl but I think it's a little less full-featured.","category":"page"},{"location":"man/winsorize_guide/#Basic-usage","page":"Winsorizing","title":"Basic usage","text":"","category":"section"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"Start with a simple distribution to visualize the effect of winsorizing","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"Random.seed!(3); x = randn(10_000);\np1 = histogram(x, bins=-4:0.1:4, color=\"blue\", label=\"distribution\", \n    framestyle=:box, size=(1250,750))\nsavefig(p1, \"p1.svg\"); nothing # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"(Image: )","category":"page"},{"location":"man/winsorize_guide/#Replace-the-outliers-based-on-quantile","page":"Winsorizing","title":"Replace the outliers based on quantile","text":"","category":"section"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"x_win = winsorize(x, probs=(0.05, 0.95));\np2 = histogram(x, bins=-4:0.1:4, color=\"blue\", label=\"distribution\", framestyle=:box); \nhistogram!(x_win, bins=-4:0.1:4, color=\"red\", opacity=0.5, label=\"winsorized\")\nsavefig(p2, \"p2.svg\"); nothing # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"(Image: )","category":"page"},{"location":"man/winsorize_guide/#One-side-trim","page":"Winsorizing","title":"One side trim","text":"","category":"section"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"x_win = winsorize(x, probs=(0, 0.8));\np3 = histogram(x, bins=-4:0.1:4, color=\"blue\", label=\"distribution\", framestyle=:box);\nhistogram!(x_win, bins=-4:0.1:4, color=\"red\", opacity=0.5, label=\"winsorized\");\nsavefig(p3, \"p3.svg\"); nothing # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"(Image: )","category":"page"},{"location":"man/winsorize_guide/#Bring-your-own-cutpoints","page":"Winsorizing","title":"Bring your own cutpoints","text":"","category":"section"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"Another type of winsorizing is to specify your own cutpoints (they do not have to be symmetric):","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"x_win = winsorize(x, cutpoints=(-1.96, 2.575));\np4 = histogram(x, bins=-4:0.1:4, color=\"blue\", label=\"distribution\", framestyle=:box); \nhistogram!(x_win, bins=-4:0.1:4, color=\"red\", opacity=0.5, label=\"winsorized\");\nsavefig(p4, \"p4.svg\"); nothing # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"(Image: )","category":"page"},{"location":"man/winsorize_guide/#Rely-on-the-computer-to-select-the-right-cutpoints","page":"Winsorizing","title":"Rely on the computer to select the right cutpoints","text":"","category":"section"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"If you do not specify either they will specified automatically","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"x_win = winsorize(x; verbose=true);\np5 = histogram(x, bins=-4:0.1:4, color=\"blue\", label=\"distribution\", framestyle=:box); \nhistogram!(x_win, bins=-4:0.1:4, color=\"red\", opacity=0.5, label=\"winsorized\");\nsavefig(p5, \"p5.svg\"); nothing # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"(Image: )","category":"page"},{"location":"man/winsorize_guide/#How-not-to-replace-outliers","page":"Winsorizing","title":"How not to replace outliers","text":"","category":"section"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"If you do not want to replace the value by the cutoffs, specify replace_value=missing:","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"x_win = winsorize(x, cutpoints=(-2.575, 1.96), replace_value=missing);\np6 = histogram(x, bins=-4:0.1:4, color=\"blue\", label=\"distribution\", framestyle=:box); \nhistogram!(x_win, bins=-4:0.1:4, color=\"red\", opacity=0.5, label=\"winsorized\");\nsavefig(p6, \"p6.svg\"); nothing # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"(Image: )","category":"page"},{"location":"man/winsorize_guide/#How-to-choose-your-replacement","page":"Winsorizing","title":"How to choose your replacement","text":"","category":"section"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"The replace_value command gives you some flexibility to do whatever you want in your outlier data transformation","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"x_win = winsorize(x, cutpoints=(-2.575, 1.96), replace_value=(-1.96, 1.28));\np7 = histogram(x, bins=-4:0.1:4, color=\"blue\", label=\"distribution\", framestyle=:box); \nhistogram!(x_win, bins=-4:0.1:4, color=\"red\", opacity=0.5, label=\"winsorized\");\nsavefig(p7, \"p7.svg\"); nothing # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"(Image: )","category":"page"},{"location":"man/winsorize_guide/#Within-a-DataFrame","page":"Winsorizing","title":"Within a DataFrame","text":"","category":"section"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"I try to mimick the gtools winsor example","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"Winsorize one variable","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"df = DataFrame(PalmerPenguins.load())\n\n# gstats winsor wage\ntransform!(df, :body_mass_g => (x -> winsorize(x, probs=(0.1, 0.9)) ) => :body_mass_g_w) \n\np8 = histogram(df.body_mass_g, bins=2700:100:6300, color=\"blue\", label=\"distribution\", framestyle=:box); \nhistogram!(df.body_mass_g_w, bins=2700:100:6300, color=\"red\", opacity=0.5, label=\"winsorized\");\nsavefig(p8, \"p8.svg\"); nothing # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"(Image: )","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"Winsorize multiple variables","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"# gstats winsor wage age hours, cuts(0.5 99.5) replace\nvar_to_winsorize = [\"bill_length_mm\", \"bill_depth_mm\", \"flipper_length_mm\"]\ntransform!(df, \n    var_to_winsorize .=> (x -> winsorize(x, probs=(0.1, 0.9)) ) .=> var_to_winsorize .* \"_w\")\nshow(IOContext(stdout, :limit => true, :displaysize => (20, 100)), \n    select(df, :species, :island, :bill_length_mm, :bill_length_mm_w, \n               :bill_depth_mm, :bill_depth_mm_w, :flipper_length_mm, :flipper_length_mm_w),\n    allcols=true, allrows=false)\nnothing; # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"Winsorize on one side only","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"# left-winsorizing only, at 1th percentile; \n# cap noi gstats winsor wage, cuts(1 100); gstats winsor wage, cuts(1 100) s(_w2)\ntransform!(df, :body_mass_g => (x -> winsorize(x, probs=(0.1, 1)) ) => :body_mass_g_w )\nshow(IOContext(stdout, :limit => true, :displaysize => (20, 100)), \n    select(df, :species, :island, :body_mass_g, :body_mass_g_w), \n    allcols=true, allrows=false)\nnothing; # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"Winsorize by groups","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"transform!(\n    groupby(df, :sex),\n    :body_mass_g => (x -> winsorize(x, probs=(0.2, 0.8)) ) => :body_mass_g_w)\np9 = histogram(df[ isequal.(df.sex, \"male\"), :body_mass_g], bins=3000:100:6300, \n    color=\"blue\", label=\"distribution\", framestyle=:box);\nhistogram!(df[ isequal.(df.sex, \"male\"), :body_mass_g_w], bins=3000:100:6300, \n    color=\"red\", opacity=0.5, label=\"winsorized\");\nsavefig(p9, \"p9.svg\"); nothing # hide","category":"page"},{"location":"man/winsorize_guide/","page":"Winsorizing","title":"Winsorizing","text":"(Image: )","category":"page"},{"location":"lib/public/#Public-Interface","page":"Public Interface","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/#BazerData-Module","page":"Public Interface","title":"BazerData Module","text":"","category":"section"},{"location":"lib/public/#BazerData.panel_fill!-Tuple{DataFrames.DataFrame, Symbol, Symbol, Union{Symbol, Vector{Symbol}}}","page":"Public Interface","title":"BazerData.panel_fill!","text":"panel_fill!(...)\n\nSame as panel_fill but with modification in place\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BazerData.panel_fill-Tuple{DataFrames.DataFrame, Symbol, Symbol, Union{Symbol, Vector{Symbol}}}","page":"Public Interface","title":"BazerData.panel_fill","text":"panel_fill(\n    df::DataFrame,\n    id_var::Symbol, \n    time_var::Symbol, \n    value_var::Union{Symbol, Vector{Symbol}};\n    gap::Union{Int, DatePeriod} = 1, \n    method::Symbol = :backwards, \n    uniquecheck::Bool = true,\n    flag::Bool = false,\n    merge::Bool = false\n)\n\nArguments\n\ndf::AbstractDataFrame: a panel dataset\nid_var::Symbol: the individual index dimension of the panel\ntime_var::Symbol: the time index dimension of the panel (must be integer or a date)\nvalue_var::Union{Symbol, Vector{Symbol}}: the set of columns we would like to fill\n\nKeywords\n\ngap::Union{Int, DatePeriod} = 1 : the interval size for which we want to fill data\nmethod::Symbol = :backwards: the interpolation method to fill the data   options are: :backwards (default), :forwards, :linear, :nearest   email me for other interpolations (anything from Interpolations.jl is possible)\nuniquecheck::Bool = true: check if panel is clean\nflag::Bool = false: flag the interpolated values\nmerge::Bool = false: merge the new values with the input dataset\n\nReturns\n\nAbstractDataFrame: \n\nExamples\n\nSee tests\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BazerData.tabulate-Tuple{DataFrames.AbstractDataFrame, Union{Symbol, Vector{Symbol}}}","page":"Public Interface","title":"BazerData.tabulate","text":"tabulate(df::AbstractDataFrame, cols::Union{Symbol, Array{Symbol}};\n    reorder_cols=true, out::Symbol=:stdout)\n\nThis was forked from TexTables.jl and was inspired by https://github.com/matthieugomez/statar\n\nArguments\n\ndf::AbstractDataFrame: Input DataFrame to analyze\ncols::Union{Symbol, Vector{Symbol}}: Single column name or vector of column names to tabulate\ngroup_type::Union{Symbol, Vector{Symbol}}=:value: Specifies how to group each column:\n:value: Group by the actual values in the column\n:type: Group by the type of values in the column\nVector{Symbol}: Vector combining :value and :type for different columns\nreorder_cols::Bool=true  Whether to sort the output by sortable columns\nformat_tbl::Symbol=:long How to present the results long or wide (stata twoway)\nformat_stat::Symbol=:freq  Which statistics to present for format :freq or :pct\nskip_stat::Union{Nothing, Symbol, Vector{Symbol}}=nothing  do not print out all statistics (only for string)\nout::Symbol=:stdout  Output format:\n:stdout  Print formatted table to standard output (returns nothing)\n:df  Return the result as a DataFrame\n:string Return the formatted table as a string\n\nReturns\n\nNothing if out=:stdout\nDataFrame if out=:df\nString if out=:string\n\nOutput Format\n\nThe resulting table contains the following columns:\n\nSpecified grouping columns (from cols)\nfreq: Frequency count\npct: Percentage of total\ncum: Cumulative percentage\n\nTO DO\n\nallow user to specify order of columns (reorder = false flag)\n\nExamples\n\nSee the README for more examples\n\n# Simple frequency table for one column\ntabulate(df, :country)\n\n## Group by value type\ntabulate(df, :age, group_type=:type)\n\n# Multiple columns with mixed grouping\ntabulate(df, [:country, :age], group_type=[:value, :type])\n\n# Return as DataFrame instead of printing\nresult_df = tabulate(df, :country, out=:df)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BazerData.tlag-Tuple{Any, Any}","page":"Public Interface","title":"BazerData.tlag","text":"tlag(x, t_vec; n = nothing, checksorted = true, verbose = false)\n\nCreate a lagged version of array x based on time vector t_vec, where each element is shifted backward in time by a specified amount n.\n\nArguments\n\nx: Array of values to be lagged\nt_vec: Vector of time points corresponding to each element in x \n\nKeyword Arguments\n\nn: Time gap for lagging. If nothing (default), uses the minimal unit difference between time points.\nchecksorted: If true (default), verifies that t_vec is sorted in ascending order\nverbose: If true, prints informational messages about the process\n\nReturns\n\nAn array of the same length as x where each element is the value of x from n time units ago, or missing if no corresponding past value exists\n\nNotes\n\nTime vectors must be strictly sorted (ascending order)\nThe time gap n must be positive\nUses linear scan to match time points\nFor Date types, no type checking is performed on n\nElements at the beginning will be missing if they don't have values from n time units ago\nSee PanelShift.jl for original implementation\n\nErrors\n\nIf t_vec is not sorted and checksorted=true\nIf n is not positive\nIf x and t_vec have different lengths\nIf n has a type that doesn't match the difference type of t_vec\n\nExamples\n\njulia> tlag([1, 2, 3], [1, 2, 3], n = 1)\n3-element Vector{Union{Missing, Int64}}:\n  missing\n 1\n 2\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BazerData.tlead-Tuple{Any, Any}","page":"Public Interface","title":"BazerData.tlead","text":"tlead(x, t_vec; n = nothing, checksorted = true, verbose = false)\n\nCreate a leading version of array x based on time vector t_vec, where each element is shifted forward in time by a specified amount n.\n\nArguments\n\nx: Array of values to be led\nt_vec: Vector of time points corresponding to each element in x\n\nKeyword Arguments\n\nn: Time gap for leading. If nothing (default), uses the minimal unit difference between time points.\nchecksorted: If true (default), verifies that t_vec is sorted in ascending order\nverbose: If true, prints informational messages about the process\n\nReturns\n\nAn array of the same length as x where each element is the value of x from n time units in the future, or missing if no corresponding future value exists\n\nNotes\n\nTime vectors must be strictly sorted (ascending order)\nThe time gap n must be positive\nUses linear scan to match time points\nFor Date types, no type checking is performed on n\nElements at the end will be missing if they don't have values from n time units in the future\nSee PanelShift.jl for original implementation\n\nErrors\n\nIf t_vec is not sorted and checksorted=true\nIf n is not positive\nIf x and t_vec have different lengths\nIf n has a type that doesn't match the difference type of t_vec\n\nExamples\n\njulia> tlead([1, 2, 3], [8, 9, 10], n = 1)\n3-element Vector{Union{Missing, Int64}}:\n 2\n 3\n  missing\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BazerData.tshift-Tuple{Any, Any}","page":"Public Interface","title":"BazerData.tshift","text":"tshift(x, t_vec; n = nothing, kwargs...)\n\nCreate a shifted version of array x based on time vector t_vec, where each element is shifted by a specified amount n. Acts as a unified interface to tlag and tlead.\n\nArguments\n\nx: Array of values to be shifted\nt_vec: Vector of time points corresponding to each element in x\n\nKeyword Arguments\n\nn: Time gap for shifting. If positive, performs a lag operation (backward in time);       if negative, performs a lead operation (forward in time).      If nothing (default), defaults to a lag operation with minimal unit difference.\nkwargs...: Additional keyword arguments passed to either tlag or tlead\n\nReturns\n\nAn array of the same length as x where each element is the value of x shifted by n time units, or missing if no corresponding value exists at that time point\n\nNotes\n\nPositive n values call tlag (backward shift in time)\nNegative n values call tlead (forward shift in time)\nIf n is not specified, issues a warning and defaults to a lag operation\n\nExamples\n\njulia> tshift([1, 2, 3], [-3, -2, -1], n = 1)\n3-element Vector{Union{Missing, Int64}}:\n  missing\n 1\n 2\n\njulia> tshift([1, 2, 3], [-3, -2, -1], n = -1)\n3-element Vector{Union{Missing, Int64}}:\n 2\n 3\n  missing\n\n\nSee also: tlag, tlead\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BazerData.winsorize-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T","page":"Public Interface","title":"BazerData.winsorize","text":"winsorize(\n    x::AbstractVector; \n    probs::Union{Tuple{Real, Real}, Nothing} = nothing,\n    cutpoints::Union{Tuple{Real, Real}, Nothing} = nothing,\n    replace::Symbol = :missing\n    verbose::Bool=false\n)\n\nArguments\n\nx::AbstractVector: a vector of values\n\nKeywords\n\nprobs::Union{Tuple{Real, Real}, Nothing}: A vector of probabilities that can be used instead of cutpoints\ncutpoints::Union{Tuple{Real, Real}, Nothing}: Cutpoints under and above which are defined outliers. Default is (median - five times interquartile range, median + five times interquartile range). Compared to bottom and top percentile, this takes into account the whole distribution of the vector\nreplace_value::Tuple:  Values by which outliers are replaced. Default to cutpoints. A frequent alternative is missing. \nIQR::Real: when inferring cutpoints what is the multiplier from the median for the interquartile range. (median ± IQR * (q75-q25))\nverbose::Bool: printing level\n\nReturns\n\nAbstractVector: A vector the size of x with substituted values \n\nExamples\n\nSee tests\n\nThis code is based on Matthieu Gomez winsorize function in the statar R package \n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BazerData.xtile-Union{Tuple{T}, Tuple{AbstractVector{T}, Integer}} where T<:Real","page":"Public Interface","title":"BazerData.xtile","text":"xtile(data::Vector{T}, n_quantiles::Integer, \n             weights::Union{Vector{Float64}, Nothing}=nothing)::Vector{Int} where T <: Real\n\nCreate quantile groups using Julia's built-in weighted quantile functionality.\n\nArguments\n\ndata: Values to group\nn_quantiles: Number of groups\nweights: Optional weights of weight type (StatasBase)\n\nExamples\n\nsales = rand(10_000);\na = xtile(sales, 10);\nb = xtile(sales, 10, weights=Weights(repeat([1], length(sales))) );\n@assert a == b\n\n\n\n\n\n","category":"method"},{"location":"#BazerData.jl","page":"Home","title":"BazerData.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Useful functions for working with data: BazerData.jl is a placeholder package for some functions that I use in julia frequently.","category":"page"},{"location":"","page":"Home","title":"Home","text":"So far the package provides a five functions","category":"page"},{"location":"","page":"Home","title":"Home","text":"tabulate some data (tabulate)\ncreate category based on quantile (xtile)\nwinsorize some data (winsorize)\nfill unbalanced panel data (panel_fill)\nlead and lag functions (tlead|tlag)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that as the package grow in different directions, dependencies might become overwhelming. The readme serves as documentation; there might be more examples inside of the test folder.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BazerData.jl is a not yet a registered package. You can install it from github  via","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg\nPkg.add(url=\"https://github.com/eloualiche/BazerData.jl\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Tabulate-data","page":"Home","title":"Tabulate data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The tabulate function tries to emulate the tabulate function from stata (see oneway here or twoway here). This relies on the DataFrames.jl package and is useful to get a quick overview of the data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DataFrames\nusing BazerData\nusing PalmerPenguins\n\ndf = DataFrame(PalmerPenguins.load())\n\ntabulate(df, :island)\ntabulate(df, [:island, :species])\n\n# If you are looking for groups by type (detect missing e.g.)\ndf = DataFrame(x = [1, 2, 2, \"NA\", missing], y = [\"c\", \"c\", \"b\", \"z\", \"d\"])\ntabulate(df, [:x, :y], group_type = :type) # only types for all group variables\ntabulate(df, [:x, :y], group_type = [:value, :type]) # mix value and types","category":"page"},{"location":"","page":"Home","title":"Home","text":"I have not implemented all the features of the stata tabulate function, but I am open to suggestions.","category":"page"},{"location":"#xtile","page":"Home","title":"xtile","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the doc or the tests for examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sales = rand(10_000);\na = xtile(sales, 10);\nb = xtile(sales, 10, weights=Weights(repeat([1], length(sales))) );\n# works on strings\ncities = [randstr() for _ in 10]\nxtile(cities, 10)","category":"page"},{"location":"#Winsorize-data","page":"Home","title":"Winsorize data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the doc for examples","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is fairly standard and I offer options to specify probabilities or cutpoints; moreover you can replace the values that are winsorized with a missing, the cutpoints, or some specific values. There is a winsor function in StatsBase.jl but I think it's a little less full-featured.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the doc for examples","category":"page"},{"location":"","page":"Home","title":"Home","text":"df = DataFrame(PalmerPenguins.load())\nwinsorize(df.flipper_length_mm, probs=(0.05, 0.95)) # skipmissing by default\ntransform(df, :flipper_length_mm =>\n    (x->winsorize(x, probs=(0.05, 0.95), replace_value=missing)), renamecols=false)","category":"page"},{"location":"#Filling-an-unbalanced-panel","page":"Home","title":"Filling an unbalanced panel","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sometimes it is unpractical to work with unbalanced panel data. There are many ways to fill values between dates (what interpolation to use) and I try to implement a few of them. I use the function sparingly, so it has not been tested extensively.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the following example (or the test suite) for more information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"df_panel = DataFrame(        # missing t=2 for id=1\n    id = [\"a\",\"a\", \"b\",\"b\", \"c\",\"c\",\"c\", \"d\",\"d\",\"d\",\"d\"],\n    t  = [Date(1990, 1, 1), Date(1990, 4, 1), Date(1990, 8, 1), Date(1990, 9, 1),\n          Date(1990, 1, 1), Date(1990, 2, 1), Date(1990, 4, 1),\n          Date(1999, 11, 10), Date(1999, 12, 21), Date(2000, 2, 5), Date(2000, 4, 1)],\n    v1 = [1,1, 1,6, 6,0,0, 1,4,11,13],\n    v2 = [1,2,3,6,6,4,5, 1,2,3,4],\n    v3 = [1,5,4,6,6,15,12.25, 21,22.5,17.2,1])\n\npanel_fill(df_panel, :id, :t, [:v1, :v2, :v3],\n    gap=Month(1), method=:backwards, uniquecheck=true, flag=true, merge=true)\npanel_fill(df_panel, :id, :t, [:v1, :v2, :v3],\n    gap=Month(1), method=:forwards, uniquecheck=true, flag=true, merge=true)\npanel_fill(df_panel, :id, :t, [:v1, :v2, :v3],\n    gap=Month(1), method=:linear, uniquecheck=true, flag=true, merge=true)","category":"page"},{"location":"#Leads-and-lags","page":"Home","title":"Leads and lags","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is largely \"borrowed\" (copied) from @FuZhiyu PanelShift.jl package. See the tests for more examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"x, t = [1, 2, 3], [1, 2, 4]\ntlag(x, t) \ntlag(x, t, n=2) \n\nusing Dates;\nt = [Date(2020,1,1); Date(2020,1,2); Date(2020,1,4)];\ntlag(x, t)\ntlag(x, t, n=Day(2)) # specify two-day lags","category":"page"},{"location":"#Other-stuff","page":"Home","title":"Other stuff","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See my other package ","category":"page"},{"location":"","page":"Home","title":"Home","text":"BazerUtils.jl which groups together data wrangling functions.\nFinanceRoutines.jl which is more focused and centered on working with financial data.\nTigerFetch.jl which simplifies downloading shape files from the Census.","category":"page"},{"location":"man/xtile_guide/#Xtile","page":"Xtile","title":"Xtile","text":"","category":"section"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"The function xtile tries to emulate stata xtile function.","category":"page"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"There is a BinScatter.jl package which already implements these features.","category":"page"},{"location":"man/xtile_guide/#Basic-usage","page":"Xtile","title":"Basic usage","text":"","category":"section"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"Start with a simple distribution to visualize the effect of winsorizing","category":"page"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"Random.seed!(3); x = randn(10_000);\np1 = histogram(x, \n    bins=-4:0.1:4, alpha=0.25, color=\"grey\", label=\"\",\n    framestyle=:box, size=(1250,750))\nsavefig(p1, \"p1.svg\"); nothing # hide","category":"page"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"(Image: )","category":"page"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"The quintiles split the distribution:","category":"page"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"x_tile = hcat(x, xtile(x, 5))\np2 = histogram(x, bins=-4:0.1:4, alpha=0.25, color=\"grey\", \n    label=\"\", framestyle=:box); \n[ histogram!(x_tile[ x_tile[:, 2] .== i , 1], bins=-4:0.1:4, \n             alpha=0.75, label=\"quantile bin $i\") \n  for i in 0:4 ];\nsavefig(p2, \"p2.svg\"); nothing # hide","category":"page"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"(Image: )","category":"page"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"It is possible to include weights","category":"page"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"x_sorted = sort(x)\nx_tile_weights = xtile(x_sorted, 5, \n                       weights=Weights([ log(i)/i for i in 1:length(x)]) ) \np3 = histogram(x, bins=-4:0.1:4, alpha=0.25, color=\"grey\", \n    label=\"\", framestyle=:box); \n[ histogram!(x_sorted[x_tile_weights.==i], bins=-4:0.1:4, \n             alpha=0.75, label=\"quantile bin $i\") \n  for i in 0:4 ];\nsavefig(p3, \"p3.svg\"); nothing # hide","category":"page"},{"location":"man/xtile_guide/","page":"Xtile","title":"Xtile","text":"(Image: )","category":"page"}]
}
